<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[HashMap-1.8版]]></title>
      <url>/chengasd.github.io/2018/01/28/HashMap-1-8%E7%89%88/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2018/01/28/HashMap-1-8版/1.jpg">
<a id="more"></a>
<h2 id="Map关系继承图"><a href="#Map关系继承图" class="headerlink" title="Map关系继承图"></a>Map关系继承图</h2><img src="/chengasd.github.io/2018/01/28/HashMap-1-8版/2.png">
<h2 id="HashMap-1-8源码分析"><a href="#HashMap-1-8源码分析" class="headerlink" title="HashMap 1.8源码分析"></a>HashMap 1.8源码分析</h2><p>HashMap在1.8版本中是有数组＋链表＋红黑树实现的，如下图所示：<br><img src="/chengasd.github.io/2018/01/28/HashMap-1-8版/3.png"></p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化容量 2的四次方 默认16  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 最大容量值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 加载因子 默认0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// (1.8)一个桶的树化阈值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// (1.8)一个树的链表还原阈值 将红黑树转变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// (1.8)当需要将解决 hash 冲突的链表转变为红黑树时，需要判断下此时数组容量，若是由于数组容量太小       </span></span><br><span class="line"><span class="comment">//（小于　MIN_TREEIFY_CAPACITY　）导致的 hash 冲突太多，则不进行链表转变为红黑树操作</span></span><br><span class="line"><span class="comment">// 转为利用resize() 函数对　hashMap 扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 保存Node&lt;K,V&gt;节点的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 由hashMap 中 Node&lt;K,V&gt;　节点构成的 set</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// k/v映射关系的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; </span><br><span class="line"> <span class="comment">// 这个HashMap结构变化(k\v映射关系数量改变，或者rehash)的次数,</span></span><br><span class="line"><span class="comment">// 用来实现HashMap的iterator的fail-fast特点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; </span><br><span class="line"><span class="comment">// 阈值 ＝ 容量＊加载因子 ,当HashMap的下一个元素size&gt;=threshold时,会进行rehash操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 记录 hashMap 装载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>Node节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;     <span class="comment">//hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;        <span class="comment">//key值</span></span><br><span class="line">    V value;            <span class="comment">//value值</span></span><br><span class="line">    Node&lt;K,V&gt; next;     <span class="comment">//下一个元素</span></span><br><span class="line">    <span class="comment">//保存一个键值对，并持有指向下一个键值对的引用，构成了单向链表了。</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Treenode</strong><br>红黑树相关的存储结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 存储当前节点的父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;    <span class="comment">// 存储当前节点的左孩子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;   <span class="comment">// 存储当前节点的右孩子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// 存储当前节点的前一个孩子</span></span><br><span class="line">    <span class="keyword">boolean</span> red;           <span class="comment">// 存储当前节点的颜色（红、黑）</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  获取根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 红黑数put元素</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 红黑树相关操作</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>1、指定初始容量和加载因子<br>2、指定初始容量，采用默认因子<br>3、所有数据都采用默认数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//返回最接近initialCapacity的2的幂，若指定初始容量为９，则实际 hashMap容量为16*/</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">//当 n＝8 (1 0 0)时， &gt;&gt;&gt;1 = 4 (0 1 0) |=12 (1 1 0) </span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;  <span class="comment">//a|b,即把a和b做按位或   &gt;&gt;&gt;代表无符号右移</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="put增加元素"><a href="#put增加元素" class="headerlink" title="put增加元素"></a>put增加元素</h4><img src="/chengasd.github.io/2018/01/28/HashMap-1-8版/4.png" title="put元素流程图">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1、增加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、计算hash值 </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// a^b a异或b  1^0 ＝ 1</span></span><br><span class="line">    <span class="comment">//key 的 hash　值的计算是通过hashCode()的高16位异或低16位实现的：</span></span><br><span class="line">    <span class="comment">//(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，</span></span><br><span class="line">    <span class="comment">//这么做在数组的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、增加元素 onlyIfAbsent ＝true时，如果存在则不改变已有元素值。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空时则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 4、计算插入的数组下标 i＝ (n - 1) &amp; hash ，按位与运算  为什么不是％n取膜运算？</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果该数组下未有节点，直接新建</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 5.1、数组下有节点 ，判断key是否等于头节点p ，直接覆盖。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 5.2、如果为红黑树时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 5.3、当为单向链表时</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 插入该元素</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6、待插入的元素已经存在 onlyIfAbsent 判断是否需要覆盖值 ， true为不覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modCount＋＋ 同1.7 用于判断多线程下快速失败</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、在红黑树增加元素</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//7.1、从根节点查找合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                dir = -<span class="number">1</span>;   <span class="comment">//7.2、 dir小于0 ， 接下来查找当前节点左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                dir = <span class="number">1</span>;    <span class="comment">//7.2、 dir大于0 ， 接下来查找当前节点右孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="comment">//7.2、 代表hash 值相同，key值相同</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*  满足一下几点</span></span><br><span class="line"><span class="comment">                1、当前节点与待插入节点　key　不同,　hash 值相同</span></span><br><span class="line"><span class="comment">                2、ｋ是不可比较的，即ｋ并未实现　comparable&lt;K&gt;　接口</span></span><br><span class="line"><span class="comment">                （若 k 实现了comparable&lt;K&gt;　接口，comparableClassFor（k）返回的是ｋ的　class,而不是　null）</span></span><br><span class="line"><span class="comment">               3、或者　compareComparables(kc, k, pk)　返回值为 0</span></span><br><span class="line"><span class="comment">　　　　　　　　　　　(pk 为空或者按照 k.compareTo(pk) 返回值为０，可能是由于　ｋ的compareTo 方法实现不当引起的，</span></span><br><span class="line"><span class="comment">　　　　　　　　　　　compareTo 判定相等，而上个 else if　中　equals 判定不等)*/</span></span><br><span class="line">                <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                <span class="comment">//在以当前节点为根的整个树上搜索是否存在待插入节点（只会搜索一次）</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                    searched = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                         <span class="comment">//若树中存在待插入节点，直接返回</span></span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                dir = tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">            <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//8、找到了待插入的位置，xp 为待插入节点的父节点，TreeNode节点中既存在树状关系，也存在链式关系，并且是双端链表</span></span><br><span class="line">                Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                    xp.left = x;  <span class="comment">// xp节点的左孩子定义为x</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    xp.right = x;</span><br><span class="line">                xp.next = x;</span><br><span class="line">                x.parent = x.prev = xp;</span><br><span class="line">                <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                <span class="comment">//9、插入节点后进行二叉树的平衡操作</span></span><br><span class="line">                moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="treeifyBin方法转红黑数"><a href="#treeifyBin方法转红黑数" class="headerlink" title="treeifyBin方法转红黑数"></a>treeifyBin方法转红黑数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果数组长度小于64 只是扩容，不会转成红黑数</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将该节点转换为数节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)     <span class="comment">//确定头节点</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">美团－Java 8系列之重新认识HashMap</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap-1.7版]]></title>
      <url>/chengasd.github.io/2018/01/11/HashMap-1-7/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2018/01/11/HashMap-1-7/1.jpg">
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>1、HashMap是基于数组+链表的结构组成。<br>数组的特点：连续空间，寻址迅速，但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。<br>链表的特点：空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。<br>2、HashMap是非线程安全的，HashTable是线程安全的，但通过synchronized关键字实现，效率不高。<br>3、HashMap的键和值都允许有null值存在，而HashTable则不行。<br>4、HashMap继承自AbstractMap<k,v>，而HashTable继承自Dictionary<k,v><br><a id="more"></a></k,v></k,v></p>
<p>推荐一个在线数据结构操作动画图的连接<br><a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/OpenHash.html</a><br><img src="/chengasd.github.io/2018/01/11/HashMap-1-7/2.jpg"></p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">// 初始化容量 2的四次方 默认16  why必须为2的次幂？ 为了保证计算数组下标值的低重复率。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 最大容量值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 加载因子 默认0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// Entry数组，而Entry本身实现了链表 ， 所以hashMap本质就是数组＋链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">// k/v映射关系的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 阈值 ＝ 容量＊加载因子 ,当HashMap的下一个元素size&gt;=threshold时,会进行rehash操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 记录 hashMap 装载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 这个HashMap结构变化(k\v映射关系数量改变，或者rehash)的次数,</span></span><br><span class="line"><span class="comment">// 用来实现HashMap的iterator的fail-fast特点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<h3 id="Entry内部类"><a href="#Entry内部类" class="headerlink" title="Entry内部类"></a>Entry内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;        <span class="comment">// key值</span></span><br><span class="line">    V value;            <span class="comment">// value值</span></span><br><span class="line">    Entry&lt;K,V&gt; next;    <span class="comment">// 下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> hash;           <span class="comment">// hash值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Map.Entry保存一个键值对，并持有指向下一个键值对的引用，构成了单向链表了。</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="put增加元素"><a href="#put增加元素" class="headerlink" title="put增加元素"></a>put增加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1 计算key对应的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2 通过hash值&amp;table.length-1获得该key存放table中的bucketIndex</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 3 判断同一个数组下标的链表中的key元素是否一致，一致则替换valye值。</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、Map结构变化次数累计,fail-fast的实现。  </span></span><br><span class="line">    <span class="comment">// 如果多个线程访问，得到Iterator后，当发现modCount变化，抛出ConcurrentModificationException</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 5、如果没有这个key  则插入该元素</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 6、判断是否超过阀值，超过则扩容，重新计算下标</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7、在数组[bucketIndex］的链表上加入该key－value值</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数组下标 h＝hash值 length ＝ 当前数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// h&amp; (length-1)运算等价于对length－1 取模</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加结点，总是从链表的表头处插入新结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rehash重建操作"><a href="#rehash重建操作" class="headerlink" title="rehash重建操作"></a>rehash重建操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、newCapacity 新容量 ＝原来的容量＊2 ，即翻倍</span></span><br><span class="line"><span class="comment">// 2、把oldTable里的元素拷贝到 newTable ，并赋值到table中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>): <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、重新保存原来table中的元素到newTable中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 2、遍历table数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">// 3、遍历数组对应的单向链表中的元素</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 4、是否需要重新计算hash值</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5、重新计算该元素对应的新数组下标</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 6.1、newTable[i]==null表示首次进入这个桶,那么清空e.next的引用。</span></span><br><span class="line">            <span class="comment">// 6.2、newTable[i]!=null表示这个桶已经放入了元素，那么开始形成链表。并且准备把首结点后移，从头部插入一个新结点</span></span><br><span class="line">            <span class="comment">// 会出现死循环 即环链表！</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/chengasd.github.io/2018/01/11/HashMap-1-7/HashMap01.jpg">
<p>多线程下形成环链表的步骤可见：<br><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p>
<h4 id="Fast-fail机制（快速失败）"><a href="#Fast-fail机制（快速失败）" class="headerlink" title="Fast-fail机制（快速失败）"></a>Fast-fail机制（快速失败）</h4><p>在遍历过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote>
<p>1、当两个不同的键对象的hashcode相同时会怎样？ </p>
</blockquote>
<p>它们会储存在同一个数组下标位置的单向链表中，后加入的为头元素。</p>
<blockquote>
<p>2、如果两个键的hashcode相同，你如何获取值对象？</p>
</blockquote>
<p>HashMap会使用键对象的hashcode找到bucket下标位置，再调用keys.equals()方法去找到链表中正确的节点。</p>
<blockquote>
<p>3、什么是碰撞</p>
</blockquote>
<p>如果出现了重复的hashCode，就称作碰撞。</p>
<blockquote>
<p>4、为什么String, Interger这样的包装类适合作为键？</p>
</blockquote>
<p>String是final不可变的，而且已经重写了equals()和hashCode()方法了。因为为了要计算hashCode()，就要防止键值改变。</p>
<blockquote>
<p>5、equals() 和 hashcode()方法关系</p>
</blockquote>
<p>equals()相等的两个对象，hashcode()一定相等，equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<p>一个对象只要实现了Serilizable接口，这个对象就可以被序列化.<br>而某些场景我们不希望有些属性被序列化，这时候我们就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"><span class="keyword">package</span> 序列化;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用transient关键字不序列化某个变量</span></span><br><span class="line"><span class="comment"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinchengjian</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"mia"</span>);</span><br><span class="line">        user.setPasswd(<span class="string">"123456"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"read before Serializable: "</span>);</span><br><span class="line">        System.out.println(<span class="string">"username: "</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"password: "</span> + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/yinchengjian/学习/vim/user.txt"</span>));</span><br><span class="line">            os.writeObject(user); <span class="comment">// 将User对象写进文件</span></span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                    <span class="string">"/Users/yinchengjian/学习/vim/user.txt"</span>));</span><br><span class="line">            user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">"\nread after Serializable: "</span>);</span><br><span class="line">            System.out.println(<span class="string">"username: "</span> + user.getUsername());</span><br><span class="line">            System.out.println(<span class="string">"password: "</span> + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8294180014912103005L</span>;  </span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPasswd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswd</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: mia</span><br><span class="line">password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: mia</span><br><span class="line">password: <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim 常用命令总结]]></title>
      <url>/chengasd.github.io/2018/01/01/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2018/01/01/vim-常用命令总结/2.jpg">
<h2 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h2><p>在命令行窗口输入以下命令即可<br>vim 直接启动vim<br>vim 文件名 打开vim并创建对应文件名的文件</p>
<a id="more"></a>
<h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>vim file 打开单个文件<br>vim file1 file2 file3 同时打开多个文件<br>:open file 在vim窗口中打开新文件<br>:bn 切换到下一个文件<br>:bp 切换到上一个文件<br>:args 查看当前打开的文件列表<br>:e ftp://192.168.0.1/aaa.txt 打开远程文件</p>
<h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p>命令模式（vi 文件名 进入）<br>插入模式（按i键进入） 左下角显示–INSERT–<br>编辑模式（按:键进入） </p>
<h2 id="基本编辑"><a href="#基本编辑" class="headerlink" title="基本编辑"></a>基本编辑</h2><p>a       在当前光标后插入文本<br>A       在本行行尾插入文本<br>i       在当前光标前插入文本<br>I       在本行行前插入文本<br>o       在光标下插入新行<br>O       在光标上插入新行</p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><p>hjkl    光标移动1位，分别代表上、下、左、右<br>数字0    光标移动到本行开头<br>^       光标移动到第一个非空字符<br>$       光标移动到本行行尾<br>w       光标移动到下一个单词或标点开头<br>W       光标移动到下一个单词开头 忽略标点<br>b       光标移动到上一个单词或标点开头<br>B       光标移动到上一个单词开头 忽略标点<br>ctrl+f  光标下翻一页<br>ctrl+b  光标上翻一页<br>ctrl+d  光标下翻半页<br>ctrl+u  光标上翻半页<br>nG      光标移至第n行<br>G       光标移至最后一行<br>n+      光标向下跳n行<br>n-      光标向上跳n行<br>H       光标移至当前屏幕的第一行<br>L       光标移至当前屏幕的最后一行</p>
<h2 id="删除和撤销"><a href="#删除和撤销" class="headerlink" title="删除和撤销"></a>删除和撤销</h2><p>x       删除当前字符（剪切）<br>nx      向后删除当前行内的n个字符（剪切）<br>dd      删除当前行（剪切）<br>ndd     向下删除当前行在内的n行（剪切）<br>dW      删除当前单词（剪切）<br>d$      删除当前字符到当前行的末尾（剪切）<br>d0      删除当前字符到当前行的行头（剪切）<br>d^      删除当前字符到下一个非空字符（剪切）<br>dG      删除当前行到文件末尾（剪切）<br>u       撤销上一次操作<br>U       撤销当前行的所有操作<br>ctrl+r  撤销的撤销</p>
<h2 id="剪切、复制和粘贴"><a href="#剪切、复制和粘贴" class="headerlink" title="剪切、复制和粘贴"></a>剪切、复制和粘贴</h2><blockquote>
<p>x和d键实质上是剪切键。 y是复制键，p是粘贴键</p>
</blockquote>
<p>p       粘贴到当前行后面<br>P       粘贴到当前行前面<br>yy      复制当前行<br>nyy     向下复制当前行在内的n行<br>yw      当前字符到下一单词的起始处<br>y$      当前字符到当前行的末尾<br>y^      当前字符到当前行下一个非空字符<br>y0      当前字符到当前行的行首<br>yG      当前行到文件末尾</p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p>fx      光标移至本行下一处出现字符x的位置，输入分号重复上一次搜索<br>/       使用/命令后，输入要搜索的单词或短语，enter结束, n往下查询,N往上查询<br>:s/old/new      用new替换行中首次出现的old（:分号用于启动一条ex命令）<br>:s/old/new/g    用new替换行中所有的old<br>:n,m s/old/new/g用new替换从n到m行里所有的old<br>:%s/old/new/g   用new替换当前文件里所有的old<br>:set nu         显示行号<br>:set nonu       取消显示行号</p>
<h2 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h2><p>:w      仅保存文件<br>:q      退出文件，没有修改<br>:q!     放弃修改并推出文件<br>:wq     保存并退出文件<br>:w file1文件另存为file1<br>ZZ      保存并退出文件</p>
<img src="/chengasd.github.io/2018/01/01/vim-常用命令总结/1.png">
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[再见2017，你好2018]]></title>
      <url>/chengasd.github.io/2017/12/31/%E5%86%8D%E8%A7%812017%EF%BC%8C%E4%BD%A0%E5%A5%BD2018/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2017/12/31/再见2017，你好2018/3753.JPG">
<h2 id="再见2017"><a href="#再见2017" class="headerlink" title="再见2017"></a>再见2017</h2><p>眨眼间，即将告别2017。<br>这一年经历的太多，有悲有喜。<br>我还是那个我，周围的人却变了一遍，<br>有老朋友的辞职高就，也有亲人寿终离去。<br>唯一不变的是2016年要求自己做到的事还是没完成，<br>只能放到2018年继续了。<br><a id="more"></a></p>
<h3 id="跳了第一次槽"><a href="#跳了第一次槽" class="headerlink" title="跳了第一次槽"></a>跳了第一次槽</h3><p>4月份从老东家辞职了。<br>从现在最回看两年中的自己，技术谈不上有多少进步，<br>一方面是自己在学习路线上绕了很多弯导致中途放弃，<br>另一方面是接触的都是成型的系统，做的更多的是业务相关的二次开发。<br>所以毅然选择辞职，选择跳到更加偏互联网的公司。<br>也要感谢老东家，两年的经历让刚毕业的自己磨练出了如何快速定位问题。</p>
<p>在新的公司承受了更大的压力，从而更好的激发自己的潜能，<br>也接触更加前沿的技术，开阔了视野。<br>当然最重要的还是钱多了～～～</p>
<h3 id="读了几本小说"><a href="#读了几本小说" class="headerlink" title="读了几本小说"></a>读了几本小说</h3><p>京东618活动满了一堆书，技术书还没怎么翻，<br>小说倒看完两本了，捂脸。<br>渐渐喜欢去图书馆坐上一下午，看看小说。<br>毕竟书中自有黄金屋，看书的时候也能丰富更多的知识，<br>也可以把浮躁的自己沉淀下来。</p>
<p>列下今年看完的书：</p>
<blockquote>
<p><strong>《白鹿原》 ♥♥♥♥♥</strong><br>赶在电视停播的时候看的，前前后后花了16个小时看完。世界那么大，就怕看不远，在白鹿两家中，比起保守严谨的白家来说，更加钦佩激进的鹿家，处于战争的漩涡，或进或退，引起一场场风搅雪。</p>
<p><strong>《乖，摸摸头》 ♥♥♥</strong><br>说实话，书中的几个故事内容已然记不太清了，后面每次看书还是要写好读书笔记。</p>
<p><strong>《我有故事，你有酒吗？》 ♥♥♥</strong><br>很可惜这么多故事没有一个感同身受的，毕竟单身很久了，ORZ.</p>
<p><strong>《异乡人》 ♥♥♥</strong><br>订阅的B站up主推荐，也被书名吸引，看下来却感觉和这个书名不是很匹配，故事也不是那么的大起大落，比较平淡。 不过封面的一段话还是比较有深意的。<br><strong>我知道这世界我无处容身，只是，你凭什么审判我的灵魂？</strong></p>
<p><strong>《摆渡人》 ♥♥♥</strong><br>京东上面推荐的热门书籍，整体看下来，故事比较通俗易懂，但感觉这本书并不像其宣传的那么好，也许有的时候好书的界定因人而异吧。</p>
<p><strong>《我的应许之地》 ♥♥♥♥</strong><br>一本关于以色列的书籍，讲述了以色列这个国家的前身以及巴以冲突的来源，<br>还未看完，个人比较推荐。</p>
</blockquote>
<h3 id="送走了三位老人"><a href="#送走了三位老人" class="headerlink" title="送走了三位老人"></a>送走了三位老人</h3><img src="/chengasd.github.io/2017/12/31/再见2017，你好2018/3752.JPG">
<p>一年送走了三位老人。<br>3月7号，奶奶因病离世。<br>12月22号，爷爷也离去。<br>12月28号，外公寿终。</p>
<p>在奶奶和外公走之前都回去看到最后一面。<br>漂泊在外，能做到的也只有千里奔丧，赶回家送老人下葬。<br>虽说生老病死乃人之常情，但当这一切发生在自己身上时，悲伤还是止不住的。<br>父辈那代都是好几个兄弟姐妹操持丧事，<br>不敢想象将来我们独生这一代该如何面对这种事。<br>平时大家还是多锻炼身体。</p>
<h3 id="独自自由行"><a href="#独自自由行" class="headerlink" title="独自自由行"></a>独自自由行</h3><img src="/chengasd.github.io/2017/12/31/再见2017，你好2018/3754.JPG">
<p>16年末实现了自己第一次出境自由行，在曼谷跨年，安排行程的时候也尽量去过人不常去的景点和城市，现在想想还是挺佩服自己的。<br>游记：<a href="http://www.mafengwo.cn/i/6621839.html" target="_blank" rel="noopener">http://www.mafengwo.cn/i/6621839.html</a></p>
<h2 id="你好2018"><a href="#你好2018" class="headerlink" title="你好2018"></a>你好2018</h2><p>18年的愿望：<br>1、保持每周读书的习惯<br>2、多深究技术，开始多写些技术博客<br>3、保持每周2次跑步<br>4、亲人&amp;自己都健健康康<br>5、也是最大的愿望 告别单身！！</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[花有重开日，人无再少年]]></title>
      <url>/chengasd.github.io/2017/12/22/%E8%8A%B1%E6%9C%89%E9%87%8D%E5%BC%80%E6%97%A5%EF%BC%8C%E4%BA%BA%E6%97%A0%E5%86%8D%E5%B0%91%E5%B9%B4/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2017/12/22/花有重开日，人无再少年/1222.jpeg">
<p>没有人再用孙子称呼我了。</p>
<p>从来没想到一切来的这么的突然，3月才送走亲爱的奶奶，爷爷也从此刻离开了。</p>
<p>7年漂泊在外，每年春节回去只知道呆在家里玩电脑，和朋友聚会，去看望爷爷奶奶的次数真的少之又少，现在真的想回报您们却没有机会了。</p>
<a id="more"></a>
<p>小时候在爷爷奶奶家玩，奶奶总是包着馄饨，做团子，爷爷下地种菜分给各家烧菜吃，一家人在门口刮丝瓜皮，画面都是那么的熟悉。我开始寄宿上高中，奶奶会塞钱给我让我自己买东西吃，看着手里零散的纸票钱，我知道这是您们天天起早跑到市场卖菜挣得血汗钱，省吃俭用地过日子，每年过年还是包红包给每个孙子，走的时候也没享受什么福，来不及向您们说声道谢，从不曾对您们说过一声谢谢，只希望在另外一个世界，您们可以不用再受苦了。</p>
<p>对不起。</p>
<pre><code>————记于 23号宝安机场
</code></pre>]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[活动公共系统设计]]></title>
      <url>/chengasd.github.io/2017/12/19/%E6%B4%BB%E5%8A%A8%E5%85%AC%E5%85%B1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>①单品、满减、搭售等各个活动信息都是独立的一套活动表。<br>②每次新增促销活动需要重新开发活动相关crud代码。<br>③不利于维护，代码冗余，无意义的重复开发较多。</p>
<h2 id="1、整理后的活动公共字段"><a href="#1、整理后的活动公共字段" class="headerlink" title="1、整理后的活动公共字段"></a>1、整理后的活动公共字段</h2><h3 id="整理后活动可以分为五个维度"><a href="#整理后活动可以分为五个维度" class="headerlink" title="整理后活动可以分为五个维度"></a>整理后活动可以分为五个维度</h3><table>
<thead>
<tr>
<th style="text-align:left">维度</th>
<th style="text-align:left">字段</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">活动基本信息</td>
<td style="text-align:left">活动名称</td>
<td style="text-align:left">活动时间</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">活动作用域</td>
<td style="text-align:left">Sku</td>
<td style="text-align:left">Spu</td>
<td style="text-align:left">品牌</td>
<td style="text-align:left">类目</td>
<td style="text-align:left">店铺</td>
<td style="text-align:left">排除信息</td>
</tr>
<tr>
<td style="text-align:left">促销条件</td>
<td style="text-align:left">推广平台</td>
<td style="text-align:left">订单金额</td>
<td style="text-align:left">订单数量</td>
<td style="text-align:left">用户等级</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">促销规则</td>
<td style="text-align:left">库存限购规则</td>
<td style="text-align:left">优惠金额限制</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">促销优惠</td>
<td style="text-align:left">减N元</td>
<td style="text-align:left">打N折</td>
<td style="text-align:left">送赠品</td>
<td style="text-align:left">N元促销</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<img src="/chengasd.github.io/2017/12/19/活动公共系统设计/活动公共系统.png" title="活动公共系统">
<h3 id="活动公共系统字段设计"><a href="#活动公共系统字段设计" class="headerlink" title="活动公共系统字段设计"></a>活动公共系统字段设计</h3><img src="/chengasd.github.io/2017/12/19/活动公共系统设计/活动公共系统1.png" title="活动公共系统字段设计">
]]></content>
      
        <categories>
            
            <category> 系统设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 活动公共 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 常用命令之wc、sort]]></title>
      <url>/chengasd.github.io/2017/12/11/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8Bwc/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2017/12/11/Linux-常用命令之wc/1.jpeg">
<a id="more"></a>
<h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><blockquote>
<p>wc命令用于统计给定文件中的字节数、字数、行数。</p>
</blockquote>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><ul>
<li>c 统计字节数。</li>
<li>l 统计行数。</li>
<li>w 统计单词数。</li>
<li>m 统计字符数</li>
</ul>
<p>-lcw 组合使用按行数、字数、字节数、文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc －lcw filename1</span><br></pre></td></tr></table></figure></p>
<img src="/chengasd.github.io/2017/12/11/Linux-常用命令之wc/wc.png">
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><p>1、统计vim目录下，.txt文件的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find vim/ -name &quot;*.txt&quot; | wc -l</span><br></pre></td></tr></table></figure></p>
<p>2、统计vim目录下所有txt文件的行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find vim/ -name &quot;*.txt&quot; | xargs cat | wc -l</span><br></pre></td></tr></table></figure></p>
<p>3、统计vim目录下所有txt文件排除以1开头的行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find vim/ -name &quot;*.txt&quot; | xargs cat | grep -v ^1 | wc -l</span><br></pre></td></tr></table></figure></p>
<img src="/chengasd.github.io/2017/12/11/Linux-常用命令之wc/wc1.png">
<h2 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h2><blockquote>
<p>sort命令可以进行排序，并将排序结果标准输出</p>
</blockquote>
<h3 id="命令参数-1"><a href="#命令参数-1" class="headerlink" title="命令参数"></a>命令参数</h3><ul>
<li>u 排序并且排除重复项</li>
<li>r 反向排序，即降序</li>
<li>o 可以将排序结果输出到源文件中</li>
<li>n 原来数字是按照字符串进行排序，－n采用数字大小进行排序</li>
<li>t 指定分隔符</li>
<li>k 指定哪一个分割区域进行排序</li>
</ul>
<h3 id="常用场景-1"><a href="#常用场景-1" class="headerlink" title="常用场景"></a>常用场景</h3><p>1、对文件内容进行排序  顺序   sort filename<br>2、采用数字规则对文件内容进行排序  顺序  sort -n filename<br>3、采用数字规则对文件内容进行降序排序    sort -n -r filename<br>4、按照：分号进行分割后取第四块数字进行排序  sort -n -k 4 -t : filename<br>5、将排序结果保存到源文件中  sort -n filename -o filename </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort filename</span><br><span class="line">sort -n filename</span><br><span class="line">sort -n -r filename</span><br><span class="line">sort -n -k 4 -t : filename</span><br><span class="line">sort -n -k 4 -t : filename -o filename</span><br></pre></td></tr></table></figure>
<img src="/chengasd.github.io/2017/12/11/Linux-常用命令之wc/sort.png">
<p>1、按数字统计sort.txt 并列出没行的重复次数。<br>2、按重复次数 降序 统计sort.txt中的排序<br>3、取2中的统计结果的前3条数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort -n sort.txt | uniq -c </span><br><span class="line">sort -n sort.txt | uniq -c | sort -k 1 -n -r</span><br><span class="line">sort -n sort.txt | uniq -c | sort -k 1 -n -r | head -3</span><br></pre></td></tr></table></figure>
<img src="/chengasd.github.io/2017/12/11/Linux-常用命令之wc/sort2.png">
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 常用命令之grep、ps]]></title>
      <url>/chengasd.github.io/2017/12/10/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<img src="/chengasd.github.io/2017/12/10/Linux%20常用命令/1.jpeg">
<a id="more"></a>
<p>Linux命令工作后经常用到，比如定位问题查看线上日志、shell脚本等，所以学好Linux命令还是很重要的，此篇只记录工作后比较常用的命令。</p>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><blockquote>
<p>grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
</blockquote>
<p>1、在文件中搜索单词，返回包含”test”的文本行<br>2、统计文件或者文本中包含匹配字符串的行数 -c<br>3、输出包含匹配字符串的行数 -n<br>4、搜索多个文件并查找匹配文本在哪些文件中 -l<br>5、输出除之外的所有行 -v<br>6、使用正则表达式 -E<br>7、忽略大小写 -i</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep test filename1 filename2 filename3 --color</span><br><span class="line">grep -c test filename1=</span><br><span class="line">grep -n test filename1</span><br><span class="line">grep -l test filename1 filename2</span><br><span class="line">grep -v test filename1</span><br><span class="line">grep -E &quot;[1-9]+&quot; filename1</span><br><span class="line">grep -i TEST filename1</span><br></pre></td></tr></table></figure>
<img src="/chengasd.github.io/2017/12/10/Linux%20常用命令/grep.png">
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><p>1、查找制定进程            ps -ef|grep heso<br>2、查找指定进程个数         ps -ef|grep heso -c<br>3、找出以1开头的行内容      cat test.txt | grep ^1<br>4、找出以a结尾的行内容      cat test.txt | grep a$<br>5、显示包含1231或者1234字符的内容行      cat test.txt | grep -E “1231|1234”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep heso</span><br><span class="line">ps -ef|grep java -c</span><br><span class="line">cat test.txt | grep ^1</span><br><span class="line">cat test.txt | grep a$</span><br><span class="line">cat test.txt | grep -E &quot;1231|1234&quot;</span><br></pre></td></tr></table></figure>
<img src="/chengasd.github.io/2017/12/10/Linux%20常用命令/grep2.png">
<p>1、显示匹配的后n行    grep  -A n<br>2、显示匹配的前n行    grep  -B n<br>3、显示匹配的前后n行   grep -C n</p>
<img src="/chengasd.github.io/2017/12/10/Linux%20常用命令/grep3.png">
<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><blockquote>
<p>ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
</blockquote>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>a  显示所有进程<br>-a 显示同一终端下的所有程序<br>-A 显示所有进程<br>c  显示进程的真实名称<br>-N 反向选择<br>-e 等于“-A”<br>e  显示环境变量<br>f  显示程序间的关系<br>-H 显示树状结构<br>r  显示当前终端的进程<br>T  显示当前终端的所有程序<br>u  指定用户的所有进程<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>-C&lt;命令&gt; 列出指定命令的状况<br>–lines&lt;行数&gt; 每页显示的行数<br>–width&lt;字符数&gt; 每页显示的字符数<br>–help 显示帮助信息<br>–version 显示版本显示</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="显示进程信息-aux"><a href="#显示进程信息-aux" class="headerlink" title="显示进程信息 aux"></a>显示进程信息 aux</h4><p>ps aux 是用BSD的格式来显示 java这个进程<br>输出：<br><img src="/chengasd.github.io/2017/12/10/Linux%20常用命令/ps1.png"></p>
<p>显示的项目有：USER , PID , %CPU , %MEM , VSZ , RSS , TTY , STAT , START , TIME , COMMAND</p>
<p>说明：<br>USER：该 process 属于那个使用者账号的<br>PID ：该 process 的号码<br>%CPU：该 process 使用掉的 CPU 资源百分比<br>%MEM：该 process 所占用的物理内存百分比<br>VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)<br>RSS ：该 process 占用的固定的内存量 (Kbytes)<br>TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。<br>STAT：该程序目前的状态，主要的状态有<br>R ：该程序目前正在运作，或者是可被运作<br>S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。<br>T ：该程序目前正在侦测或者是停止了<br>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态<br>START：该 process 被触发启动的时间<br>TIME ：该 process 实际使用 CPU 运作的时间<br>COMMAND：该程序的实际指令</p>
<h4 id="显示进程信息-ef"><a href="#显示进程信息-ef" class="headerlink" title="显示进程信息 -ef"></a>显示进程信息 -ef</h4><p>ps -ef 是用标准的格式显示java这个进程<br>输出：<br><img src="/chengasd.github.io/2017/12/10/Linux%20常用命令/ps2.png"><br>显示的项目有：UID , PID , PPID , C , STIME , TTY , TIME , CMD</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
